# Copyright 2024 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

"""
Test cases for the script that injects an extra GPG signing key for an
archive into signing service.
"""
import os
import shutil
from datetime import datetime, timezone
from unittest import mock

from fixtures import MockPatch, TempDir
from testtools.matchers import (
    Equals,
    MatchesListwise,
    MatchesStructure,
    StartsWith,
)
from zope.component import getUtility

from lp.archivepublisher.scripts.inject_extra_gpg_signing_key import (
    InjectExtraGPGSigningKeyScript,
)
from lp.services.config import config
from lp.services.log.logger import BufferLogger
from lp.services.scripts.base import LaunchpadScriptFailure
from lp.services.signing.enums import SigningKeyType
from lp.services.signing.interfaces.signingkey import IArchiveSigningKeySet
from lp.services.signing.tests.helpers import SigningServiceClientFixture
from lp.testing import ExpectedException, TestCaseWithFactory
from lp.testing.dbuser import dbuser
from lp.testing.faketransaction import FakeTransaction
from lp.testing.gpgkeys import gpgkeysdir
from lp.testing.layers import ZopelessDatabaseLayer


class TestInjectExtraGPGSigningKey(TestCaseWithFactory):
    layer = ZopelessDatabaseLayer

    def setUp(self):
        super().setUp()
        self.keys_dir = self.useFixture(TempDir()).path

    def makeScript(self, test_args):
        script = InjectExtraGPGSigningKeyScript(
            "test-inject",
            dbuser=config.archivepublisher.dbuser,
            test_args=test_args,
        )
        script.txn = FakeTransaction()
        script.logger = BufferLogger()
        return script

    def makeArchiveWithSigningKeyFingerprint(self):
        archive = self.factory.makeArchive()
        archive.signing_key_fingerprint = self.factory.getUniqueHexString(
            digits=40
        ).upper()
        return archive

    def test_archive_not_specified(self):
        script = self.makeScript([])
        with ExpectedException(LaunchpadScriptFailure, "Specify an archive."):
            script.main()

    def test_local_keys_directory_not_specified(self):
        script = self.makeScript(["--archive", "~user/ubuntu/archive"])
        with ExpectedException(
            LaunchpadScriptFailure,
            "Specify the directory containing the private keys.",
        ):
            script.main()

    def test_fingerprint_not_specified(self):
        script = self.makeScript(
            [
                "--archive",
                "~user/ubuntu/archive",
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        with ExpectedException(
            LaunchpadScriptFailure,
            "Specify the fingerprint of the GPG key to inject.",
        ):
            script.main()

    def test_get_archive_with_reference(self):
        archive = self.factory.makeArchive()
        script = self.makeScript(["--archive", archive.reference])
        self.assertEqual(script.getArchive(), archive)

    def test_get_archive_with_reference_archive_not_found(self):
        with ExpectedException(
            LaunchpadScriptFailure,
            "Archive '~foo/ubuntu/bar' could not be found.",
        ):
            self.makeScript(["--archive", "~foo/ubuntu/bar"]).getArchive()

    def test_archive_has_no_existing_signing_key(self):
        archive = self.factory.makeArchive()
        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                self.factory.getUniqueHexString(digits=40).upper(),
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        script.injectGPG = mock.Mock()
        script.main()
        content = script.logger.content.as_text()
        self.assertIn(
            f"Archive '{archive.reference}' does not have a signing key "
            "generated by Launchpad yet. Cannot inject an extra key without "
            "an existing key. Aborting.",
            content,
        )
        script.injectGPG.assert_not_called()

    def test_signing_key_with_fingerprint_exists_already_unassociated(self):
        archive = self.makeArchiveWithSigningKeyFingerprint()
        signing_key = self.factory.makeSigningKey(
            key_type=SigningKeyType.OPENPGP
        )
        self.assertIsNone(
            getUtility(IArchiveSigningKeySet).getByArchiveAndFingerprint(
                archive,
                signing_key.fingerprint,
            )
        )
        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                signing_key.fingerprint,
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        script.injectGPG = mock.Mock()
        script.main()
        content = script.logger.content.as_text()
        self.assertIn(
            f"Signing key with fingerprint '{signing_key.fingerprint}' "
            "exists already.",
            content,
        )
        self.assertIn(
            f"Signing key with fingerprint '{signing_key.fingerprint}' not "
            f"associated with the archive '{archive.reference}'. Adding "
            "the association.",
            content,
        )
        self.assertIn(
            "Aborting key injection into the signing service.", content
        )
        script.injectGPG.assert_not_called()
        self.assertIsNotNone(
            getUtility(IArchiveSigningKeySet).getByArchiveAndFingerprint(
                archive,
                signing_key.fingerprint,
            )
        )

    def test_signing_key_with_fingerprint_exists_already_associated(self):
        archive = self.makeArchiveWithSigningKeyFingerprint()
        signing_key = self.factory.makeSigningKey(
            key_type=SigningKeyType.OPENPGP,
            fingerprint=archive.signing_key_fingerprint,
        )
        getUtility(IArchiveSigningKeySet).create(archive, None, signing_key)
        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                signing_key.fingerprint,
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        script.injectGPG = mock.Mock()
        script.main()
        content = script.logger.content.as_text()
        self.assertIn(
            f"Signing key with fingerprint '{signing_key.fingerprint}' "
            "exists already.",
            content,
        )
        self.assertNotIn(
            f"Signing key with fingerprint '{signing_key.fingerprint}' not "
            f"associated with the archive '{archive.reference}'. Adding "
            "the association.",
            content,
        )
        self.assertIn(
            "Aborting key injection into the signing service.", content
        )
        script.injectGPG.assert_not_called()

    def test_secret_key_file_not_found(self):
        archive = self.makeArchiveWithSigningKeyFingerprint()
        fingerprint = self.factory.getUniqueHexString(digits=40).upper()
        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                fingerprint,
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        script.injectGPG = mock.Mock()
        script.main()
        content = script.logger.content.as_text()
        self.assertIn(
            f"Could not find key file at '{self.keys_dir}/{fingerprint}.gpg'.",
            content,
        )
        script.injectGPG.assert_not_called()

    def test_secret_key_file_exists(self):
        archive = self.makeArchiveWithSigningKeyFingerprint()
        fingerprint = self.factory.getUniqueHexString(digits=40).upper()
        secret_key_path = os.path.join(self.keys_dir, f"{fingerprint}.gpg")
        with open(secret_key_path, "w") as fd:
            fd.write(f"Private key {fingerprint}")
        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                fingerprint,
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        script.injectGPG = mock.Mock()
        script.main()
        content = script.logger.content.as_text()
        self.assertIn(
            f"Found key file at '{self.keys_dir}/{fingerprint}.gpg'.",
            content,
        )
        script.injectGPG.assert_called_once_with(archive, secret_key_path)

    def test_injectGPG(self):
        signing_service_client = self.useFixture(
            SigningServiceClientFixture(self.factory)
        )
        now = datetime.now()
        mock_datetime = self.useFixture(
            MockPatch(
                "lp.archivepublisher.scripts"
                ".inject_extra_gpg_signing_key.datetime"
            )
        ).mock
        mock_datetime.now = lambda: now
        archive = self.makeArchiveWithSigningKeyFingerprint()
        fingerprint = self.factory.getUniqueHexString(digits=40).upper()
        secret_key_path = os.path.join(self.keys_dir, f"{fingerprint}.gpg")
        shutil.copyfile(
            os.path.join(gpgkeysdir, "ppa-sample@canonical.com.sec"),
            secret_key_path,
        )

        script = self.makeScript(
            [
                "--archive",
                archive.reference,
                "--fingerprint",
                fingerprint,
                "--local-keys-dir",
                self.keys_dir,
            ]
        )
        with dbuser(config.archivepublisher.dbuser):
            signing_key = script.injectGPG(archive, secret_key_path)

        self.assertThat(
            signing_key,
            MatchesStructure(
                key_type=Equals(SigningKeyType.OPENPGP),
                public_key=StartsWith(
                    b"-----BEGIN PGP PUBLIC KEY BLOCK-----\n"
                ),
                date_created=Equals(now.replace(tzinfo=timezone.utc)),
            ),
        )
        with open(secret_key_path, "rb") as f:
            # Remove the GnuPG version line from the secret key bytes
            # since the GPG private key export using the GPG library
            # excludes that.
            secret_key_bytes = b"".join(
                [
                    line
                    for line in f.readlines()
                    if not line.startswith(b"Version: GnuPG")
                ]
            )
        self.assertEqual(1, signing_service_client.inject.call_count)
        self.assertThat(
            signing_service_client.inject.call_args[0],
            MatchesListwise(
                [
                    Equals(SigningKeyType.OPENPGP),
                    Equals(secret_key_bytes),
                    StartsWith(b"-----BEGIN PGP PUBLIC KEY BLOCK-----\n"),
                    Equals("Launchpad PPA for Celso áéíóú Providelo"),
                    Equals(now.replace(tzinfo=timezone.utc)),
                ]
            ),
        )
        # We assert on 'signing_key.fingerprint' here because the
        # SigningServiceClient fixture generates its own random key
        # fingerprint and returns it. The 'fingerprint' variable
        # that we have in this test is not used for anything other
        # than identifying which private key file to use for the injection.
        self.assertIsNotNone(
            getUtility(IArchiveSigningKeySet).getByArchiveAndFingerprint(
                archive, signing_key.fingerprint
            )
        )
