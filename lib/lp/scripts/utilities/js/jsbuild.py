# Copyright 2011-2018 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

"""build.py - Minifies and creates the JS build directory."""

__metaclass__ = type
__all__ = [
    'CSSComboFile',
    ]

from glob import glob
import optparse
import os
import re
import sys

import cssutils
from cssutils import settings


HERE = os.path.dirname(__file__)
BUILD_DIR = os.path.normpath(os.path.join(
    HERE, os.pardir, os.pardir, os.pardir, 'build'))
DEFAULT_SRC_DIR = os.path.normpath(os.path.join(
    HERE, os.pardir, os.pardir, os.pardir, 'app', 'javascript'))

ESCAPE_STAR_PROPERTY_RE = re.compile(br'\*([a-zA-Z0-9_-]+):')
UNESCAPE_STAR_PROPERTY_RE = re.compile(br'([a-zA-Z0-9_-]+)_ie_star_hack:')
URL_RE = re.compile(br"url\([ \"\']*([^ \"\']+)[ \"\']*\)")


def relative_path(from_file, to_file):
    """Return the relative path between from_file and to_file."""
    dir_from, base_from = os.path.split(from_file)
    if dir_from == to_file:
        return "."
    dir_to, base_to = os.path.split(to_file)
    path = os.path.relpath(dir_to, dir_from)
    if path == ".":
        return base_to
    return os.path.join(path, base_to)


class ComboFile:
    """A file made up of several combined files.

    It offers support for detecting if the file needs updating and updating it
    from it source files.
    """

    def __init__(self, src_files, target_file):
        self.src_files = src_files
        self.target_file = target_file

    def needs_update(self):
        """Return True when the file needs to be updated.

        This is usually because the target file doesn't exist yet or because
        one of the source file was modified.
        """
        # If the target file doesn't exist, we need updating!
        if not os.path.exists(self.target_file):
            return True

        # Check if the target file was modified after all the src files.
        target_mtime = os.stat(self.target_file).st_mtime
        for src_file in self.src_files:
            if os.stat(src_file).st_mtime > target_mtime:
                return True
        else:
            return False

    def log(self, msg):
        sys.stdout.write(msg + '\n')

    def update(self):
        """Update the file from its source files."""
        with open(self.target_file, 'wb') as target_fh:
            for src_file in self.src_files:
                self.log("Processing '%s'" % os.path.basename(src_file))
                target_fh.write(self.get_file_header(src_file))
                with open(src_file, 'rb') as fh:
                    content = fh.read()
                try:
                    target_fh.write(
                        self.filter_file_content(content, src_file))
                except Exception:
                    os.remove(self.target_file)
                    raise

    def get_comment(self, msg):
        """Return a byte string wrapped in a comment to include in the output.

        Can be used to help annotate the output file.
        """
        return b''

    def get_file_header(self, path):
        """Return a byte string to include before outputting a file.

        Can be used by subclasses to output a file reference in the combined
        file. Default implementation returns nothing.
        """
        return b''

    def filter_file_content(self, file_content, path):
        """Hook to process the file content before being combined."""
        return file_content


class CSSComboFile(ComboFile):
    """FileCombiner for CSS files.

    It uses the cssutils.CSSParser to convert all url() instances
    to the new location, and minify the result.
    """

    def __init__(self, src_files, target_file, resource_prefix=b"",
                 minify=True, rewrite_urls=True):
        super(CSSComboFile, self).__init__(src_files, target_file)
        self.resource_prefix = resource_prefix.rstrip(b"/")
        self.minify = minify
        self.rewrite_urls = rewrite_urls

    def get_comment(self, msg):
        return b"/* %s */\n" % msg.encode("UTF-8")

    def get_file_header(self, path):
        return self.get_comment(relative_path(self.target_file, path))

    def filter_file_content(self, file_content, path):
        """URLs are made relative to the target and the CSS is minified."""
        if self.rewrite_urls:
            src_dir = os.path.dirname(path)
            relative_src_dir = relative_path(self.target_file, src_dir)
            if relative_src_dir == ".":
                relative_parts = []
            else:
                relative_parts = relative_src_dir.encode("UTF-8").split(
                    os.path.sep.encode("UTF-8"))

            def fix_relative_url(match):
                url = match.group(1)
                # Don't modify absolute URLs or 'data:' urls.
                if (url.startswith(b"http") or
                        url.startswith(b"/") or
                        url.startswith(b"data:")):
                    return match.group(0)
                parts = relative_parts + url.split(b"/")
                result = []
                for part in parts:
                    if part == b".." and result and result[-1] != b"..":
                        result.pop(-1)
                        continue
                    result.append(part)
                return b"url(%s)" % b"/".join(
                    filter(None, [self.resource_prefix] + result))
            file_content = URL_RE.sub(fix_relative_url, file_content)

        if self.minify:
            old_serializer = cssutils.ser
            cssutils.setSerializer(cssutils.serialize.CSSSerializer())
            try:
                cssutils.ser.prefs.useMinified()

                stylesheet = ESCAPE_STAR_PROPERTY_RE.sub(
                    br'\1_ie_star_hack:', file_content)
                settings.set('DXImageTransform.Microsoft', True)
                parser = cssutils.CSSParser(raiseExceptions=True)
                css = parser.parseString(stylesheet)
                stylesheet = UNESCAPE_STAR_PROPERTY_RE.sub(
                    br'*\1:', css.cssText)
                return stylesheet + b"\n"
            finally:
                cssutils.setSerializer(old_serializer)
        return file_content + b"\n"


class Builder:

    def __init__(self, name='launchpad', build_dir=BUILD_DIR,
                 src_dir=DEFAULT_SRC_DIR, extra_files=None):
        """Create a new Builder.

        :param name: The name of the package we are building. This will
            be used to compute the standalone JS and CSS files.
        :param build_dir: The directory containing the build tree.
        :param src_dir: The directory containing the source files.
        :param extra_files: List of files that should be bundled in the
            standalone file.
        """
        self.name = name
        self.build_dir = build_dir
        self.src_dir = src_dir
        # We need to support the case where this is being invoked directly
        # from source rather than a package. If this is the case, the package
        # src directory won't exist.
        if not os.path.exists(src_dir):
            self.src_dir = DEFAULT_SRC_DIR
        self.built_files = []
        self.skins = {}
        if extra_files is None:
            self.extra_files = []
        else:
            self.extra_files = extra_files

    def log(self, msg):
        sys.stdout.write(msg + '\n')

    def fail(self, msg):
        """An error was encountered, abort build."""
        sys.stderr.write(msg + '\n')
        sys.exit(1)

    def ensure_build_directory(self, path):
        """Make sure that the named relative path is a directory."""
        target_dir = os.path.join(self.build_dir, path)
        if os.path.exists(target_dir):
            if not os.path.isdir(target_dir):
                self.fail(
                    "The target path, '%s', is not a directory!" % target_dir)
        else:
            self.log('Creating %s' % target_dir)
            os.makedirs(target_dir)
        return target_dir

    def ensure_link(self, src, dst):
        """Make sure that src is linked to dst."""
        if os.path.lexists(dst):
            if not os.path.islink(dst):
                self.fail(
                    "The target path, '%s', is not a symbolic link! " % dst)
        else:
            self.log('Linking %s -> %s' % (src, dst))
            os.symlink(src, dst)

    def build_assets(self, component_name):
        """Build a component's "assets" directory."""
        join = os.path.join
        isdir = os.path.isdir

        assets_path = join(component_name, 'assets')
        src_assets_dir = join(self.src_dir, assets_path)
        if not isdir(src_assets_dir):
            return

        target_assets_dir = self.ensure_build_directory(assets_path)
        # Symlink everything except the skins subdirectory.
        self.link_directory_content(
            src_assets_dir, target_assets_dir,
            lambda src: not src.endswith('skins'))

        src_skins_dir = join(src_assets_dir, 'skins')
        if not isdir(src_skins_dir):
            return

        # Process sub-skins.
        for entry in os.scandir(src_skins_dir):
            self.build_skin(component_name, entry.name)

    def link_directory_content(self, src_dir, target_dir, link_filter=None):
        """Link all the files in src_dir into target_dir.

        This doesn't recurse into subdirectories, but will happily link
        subdirectories. It also skips linking backup files.

        :param link_filter: A callable taking the source file as a parameter.
            If the filter returns False, no symlink will be created. By
            default a symlink is created for everything.
        """
        for entry in os.scandir(src_dir):
            if entry.name.endswith('~'):
                continue
            if link_filter and not link_filter(entry.path):
                continue
            target = os.path.join(target_dir, entry.name)
            self.ensure_link(relative_path(target, entry.path), target)

    def build_skin(self, component_name, skin_name):
        """Build a skin for a particular component."""
        join = os.path.join

        skin_dir = join(component_name, 'assets', 'skins', skin_name)
        src_skin_dir = join(self.src_dir, skin_dir)
        target_skin_dir = self.ensure_build_directory(skin_dir)

        # Link everything in there
        self.link_directory_content(src_skin_dir, target_skin_dir)

        # Holds all the combined files that are part of the skin
        skin_files = self.skins.setdefault(skin_name, [])

        # Create the combined core+skin CSS file.
        for skin_file in glob(join(src_skin_dir, '*-skin.css')):
            module_name = os.path.basename(skin_file)[:-len('-skin.css')]

            target_skin_file = join(target_skin_dir, '%s.css' % module_name)
            skin_files.append(target_skin_file)

            # Combine files from the build directory so that
            # relative paths are sane.
            css_files = [
                os.path.join(target_skin_dir, os.path.basename(skin_file))]
            core_css_file = join(
                self.src_dir, component_name, 'assets',
                '%s-core.css' % module_name)
            if os.path.exists(core_css_file):
                css_files.insert(0, core_css_file)

            combined_css = CSSComboFile(css_files, target_skin_file)
            if combined_css.needs_update():
                self.log('Combining %s into %s...' % (
                    ", ".join(map(os.path.basename, css_files)),
                    target_skin_file))
                combined_css.update()

    def update_combined_css_skins(self):
        """Create one combined CSS file per skin."""
        extra_css_files = [f for f in self.extra_files if f.endswith('.css')]
        for skin_name in self.skins:
            skin_build_file = os.path.join(self.build_dir, "%s-%s.css" %
                (self.name, skin_name))

            css_files = extra_css_files + self.skins[skin_name]
            # Embedded URL rewrite should start with build/ for correct
            # filesystem location, as node-sass cannot add it.
            combined_css = CSSComboFile(
                css_files, skin_build_file, resource_prefix=b"build/")
            if combined_css.needs_update():
                self.log('Updating %s...' % skin_build_file)
                combined_css.update()

    def do_build(self):
        # We need this to be both repeatable and in the desired order
        dir_list = sorted(
            os.scandir(self.src_dir),
            key=lambda x: x.name.lower(),
            reverse=True)
        for entry in dir_list:
            if not entry.is_dir():
                continue
            self.build_assets(entry.name)
        self.update_combined_css_skins()


def get_options():
    """Parse the command line options."""
    parser = optparse.OptionParser(
        usage="%prog [options] [extra_files]",
        description=(
            "Create a build directory of CSS/JS files. "
            ))
    parser.add_option(
        '-n', '--name', dest='name', default='launchpad',
        help=('The basename of the generated compilation file. Defaults to '
            '"launchpad".'))
    parser.add_option(
        '-b', '--builddir', dest='build_dir', default=BUILD_DIR,
        help=('The directory that should contain built files.'))
    parser.add_option(
        '-s', '--srcdir', dest='src_dir', default=DEFAULT_SRC_DIR,
        help=('The directory containing the src files.'))
    return parser.parse_args()


def main():
    options, extra = get_options()

    Builder(
       name=options.name,
       build_dir=options.build_dir,
       src_dir=options.src_dir,
       extra_files=extra,
       ).do_build()
