# Copyright 2022 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

__all__ = [
    "get_vulnerability_privacy_filter",
    "Vulnerability",
    "VulnerabilitySet",
]

import operator
from datetime import timezone
from typing import Iterable

from storm.expr import SQL, Coalesce, Join, Or, Select
from storm.locals import DateTime, Int, Reference, Unicode
from storm.store import Store
from zope.component import getUtility
from zope.interface import implementer

from lp.app.enums import PUBLIC_INFORMATION_TYPES, InformationType
from lp.app.errors import (
    SubscriptionPrivacyViolation,
    UserCannotUnsubscribePerson,
)
from lp.app.interfaces.services import IService
from lp.app.model.launchpad import InformationTypeMixin
from lp.bugs.enums import VulnerabilityStatus
from lp.bugs.interfaces.buglink import IBugLinkTarget
from lp.bugs.interfaces.bugtask import BugTaskImportance
from lp.bugs.interfaces.vulnerability import (
    IVulnerability,
    IVulnerabilityActivity,
    IVulnerabilityActivitySet,
    IVulnerabilitySet,
    VulnerabilityChange,
)
from lp.bugs.model.bug import Bug
from lp.bugs.model.buglinktarget import BugLinkTargetMixin
from lp.bugs.model.vulnerabilitysubscription import VulnerabilitySubscription
from lp.registry.interfaces.accesspolicy import (
    IAccessArtifactGrantSource,
    IAccessArtifactSource,
)
from lp.registry.interfaces.role import IPersonRoles
from lp.registry.model.accesspolicy import reconcile_access_for_artifacts
from lp.registry.model.person import Person
from lp.registry.model.teammembership import TeamParticipation
from lp.services.database import bulk
from lp.services.database.constants import UTC_NOW
from lp.services.database.enumcol import DBEnum
from lp.services.database.interfaces import IStore
from lp.services.database.stormbase import StormBase
from lp.services.database.stormexpr import Array, ArrayAgg, ArrayIntersects
from lp.services.xref.interfaces import IXRefSet


@implementer(IVulnerability, IBugLinkTarget)
class Vulnerability(StormBase, BugLinkTargetMixin, InformationTypeMixin):
    __storm_table__ = "Vulnerability"

    id = Int(primary=True)

    distribution_id = Int(name="distribution", allow_none=False)
    distribution = Reference(distribution_id, "Distribution.id")

    cve_id = Int(name="cve", allow_none=True, default=None)
    cve = Reference(cve_id, "Cve.id")

    status = DBEnum(name="status", allow_none=False, enum=VulnerabilityStatus)

    description = Unicode(name="description", allow_none=True)

    notes = Unicode(name="notes", allow_none=True)

    mitigation = Unicode(name="mitigation", allow_none=True)

    importance = DBEnum(
        name="importance",
        allow_none=False,
        enum=BugTaskImportance,
        default=BugTaskImportance.UNDECIDED,
    )

    importance_explanation = Unicode(
        name="importance_explanation", allow_none=True
    )

    _information_type = DBEnum(
        enum=InformationType,
        default=InformationType.PUBLIC,
        allow_none=False,
        name="information_type",
    )

    date_created = DateTime(
        name="date_created",
        tzinfo=timezone.utc,
        allow_none=False,
        default=UTC_NOW,
    )

    date_made_public = DateTime(
        name="date_made_public", tzinfo=timezone.utc, allow_none=True
    )
    date_notice_issued = DateTime(
        name="date_notice_issued", tzinfo=timezone.utc, allow_none=True
    )
    date_coordinated_release = DateTime(
        name="date_coordinated_release", tzinfo=timezone.utc, allow_none=True
    )

    creator_id = Int(name="creator", allow_none=False)
    creator = Reference(creator_id, "Person.id")

    def __init__(
        self,
        distribution,
        status,
        importance,
        creator,
        information_type=InformationType.PUBLIC,
        cve=None,
        description=None,
        notes=None,
        mitigation=None,
        importance_explanation=None,
        date_made_public=None,
        date_notice_issued=None,
        date_coordinated_release=None,
    ):
        super().__init__()
        self.distribution = distribution
        self.cve = cve
        self.status = status
        self.importance = importance
        # Set `self._information_type` rather than `self.information_type`
        # to avoid the call to `self._reconcileAccess` while constructing
        # the instance. `VulnerabilitySet.new` deals with calling
        # `_reconcileAccess` once the instance has been fully constructed.
        self._information_type = information_type
        self.creator = creator
        self.description = description
        self.notes = notes
        self.mitigation = mitigation
        self.importance_explanation = importance_explanation
        self.date_made_public = date_made_public
        self.date_notice_issued = date_notice_issued
        self.date_coordinated_release = date_coordinated_release
        self.date_created = UTC_NOW

    @property
    def private(self):
        return self.information_type not in PUBLIC_INFORMATION_TYPES

    @property
    def title(self):
        if self.cve:
            displayname = self.cve.displayname
        else:
            displayname = "#{}".format(self.id)
        return "Vulnerability {}".format(displayname)

    @property
    def bugs(self):
        bug_ids = [
            int(id)
            for _, id in getUtility(IXRefSet).findFrom(
                ("vulnerability", str(self.id)), types=["bug"]
            )
        ]
        return list(
            sorted(bulk.load(Bug, bug_ids), key=operator.attrgetter("id"))
        )

    def createBugLink(self, bug, props=None):
        """See BugLinkTargetMixin."""
        if props is None:
            props = {}
        getUtility(IXRefSet).create(
            {("vulnerability", str(self.id)): {("bug", str(bug.id)): props}}
        )

    def deleteBugLink(self, bug):
        """See BugLinkTargetMixin."""
        getUtility(IXRefSet).delete(
            {("vulnerability", str(self.id)): [("bug", str(bug.id))]}
        )

    @property
    def information_type(self):
        return self._information_type

    @information_type.setter
    def information_type(self, information_type):
        if information_type != self._information_type:
            self._information_type = information_type
            self._reconcileAccess()

    def visibleByUser(self, user: Person) -> bool:
        """See `IVulnerability`."""
        if self.information_type in PUBLIC_INFORMATION_TYPES:
            return True
        if user is None:
            return False
        return (
            not IStore(self)
            .find(
                Vulnerability,
                Vulnerability.id == self.id,
                get_vulnerability_privacy_filter(user),
            )
            .is_empty()
        )

    def _reconcileAccess(self) -> None:
        """Reconcile the vulnerability's sharing information.

        Takes the privacy and distribution and makes the related AccessArtifact
        and AccessPolicyArtifacts match.
        """
        reconcile_access_for_artifacts(
            [self], self.information_type, [self.distribution]
        )

    @property
    def subscriptions(self):
        return Store.of(self).find(
            VulnerabilitySubscription,
            VulnerabilitySubscription.vulnerability == self,
        )

    @property
    def subscribers(self):
        return Store.of(self).find(
            Person,
            VulnerabilitySubscription.person_id == Person.id,
            VulnerabilitySubscription.vulnerability == self,
        )

    def getSubscription(self, person: Person) -> VulnerabilitySubscription:
        """Returns the person's subscription or None."""
        if person is None:
            return None
        return (
            Store.of(self)
            .find(
                VulnerabilitySubscription,
                VulnerabilitySubscription.person == person,
                VulnerabilitySubscription.vulnerability == self,
            )
            .one()
        )

    def hasSubscription(self, person: Person) -> bool:
        """See `IVulnerability`."""
        return self.getSubscription(person) is not None

    def userCanBeSubscribed(self, person: Person) -> bool:
        """See `IVulnerability`."""
        return not (
            self.information_type not in PUBLIC_INFORMATION_TYPES
            and person.is_team
            and person.anyone_can_join()
        )

    def subscribe(
        self,
        person: Person,
        subscribed_by: Person,
        ignore_permissions: bool = False,
    ) -> None:
        """See `IVulnerability`."""
        if not self.userCanBeSubscribed(person):
            raise SubscriptionPrivacyViolation(
                "Open and delegated teams cannot be subscribed to private"
                "vulnerabilities."
            )
        if self.getSubscription(person) is None:
            subscription = VulnerabilitySubscription(
                person=person, vulnerability=self, subscribed_by=subscribed_by
            )
            Store.of(subscription).flush()
        service = getUtility(IService, "sharing")
        vulnerabilities = service.getVisibleArtifacts(
            person, vulnerabilities=[self], ignore_permissions=True
        )["vulnerabilities"]
        if not vulnerabilities:
            service.ensureAccessGrants(
                [person],
                subscribed_by,
                vulnerabilities=[self],
                ignore_permissions=ignore_permissions,
            )

    def unsubscribe(
        self,
        person: Person,
        unsubscribed_by: Person,
        ignore_permissions: bool = False,
    ) -> None:
        """See `IVulnerability`."""
        subscription = self.getSubscription(person)
        if subscription is None:
            return
        if (
            not ignore_permissions
            and not subscription.canBeUnsubscribedByUser(unsubscribed_by)
        ):
            raise UserCannotUnsubscribePerson(
                "%s does not have permission to unsubscribe %s"
                % (
                    unsubscribed_by.displayname,
                    person.displayname,
                )
            )
        artifact = getUtility(IAccessArtifactSource).find([self])
        getUtility(IAccessArtifactGrantSource).revokeByArtifact(
            artifact, [person]
        )
        store = Store.of(subscription)
        store.remove(subscription)
        IStore(self).flush()


@implementer(IVulnerabilitySet)
class VulnerabilitySet:
    def new(
        self,
        distribution,
        status,
        importance,
        creator,
        information_type=InformationType.PUBLIC,
        cve=None,
        description=None,
        notes=None,
        mitigation=None,
        importance_explanation=None,
        date_made_public=None,
        date_notice_issued=None,
        date_coordinated_release=None,
    ):
        """See `IVulnerabilitySet`."""
        store = IStore(Vulnerability)
        vulnerability = Vulnerability(
            distribution=distribution,
            creator=creator,
            cve=cve,
            status=status,
            description=description,
            notes=notes,
            mitigation=mitigation,
            importance=importance,
            information_type=information_type,
            importance_explanation=importance_explanation,
            date_made_public=date_made_public,
            date_notice_issued=date_notice_issued,
            date_coordinated_release=date_coordinated_release,
        )
        store.add(vulnerability)
        vulnerability._reconcileAccess()
        store.flush()
        return vulnerability

    def findByIds(
        self, vulnerability_ids: Iterable[Int], visible_by_user: bool = None
    ):
        """See `IVulnerabilitySet`."""
        clauses = [Vulnerability.id.is_in(vulnerability_ids)]
        if visible_by_user is not None:
            clauses.append(get_vulnerability_privacy_filter(visible_by_user))
        return IStore(Vulnerability).find(Vulnerability, *clauses)


@implementer(IVulnerabilityActivity)
class VulnerabilityActivity(StormBase):
    __storm_table__ = "VulnerabilityActivity"

    id = Int(primary=True)

    vulnerability_id = Int(name="vulnerability", allow_none=False)
    vulnerability = Reference(vulnerability_id, "Vulnerability.id")

    changer_id = Int(name="changer", allow_none=False)
    changer = Reference(changer_id, "Person.id")

    date_changed = DateTime(
        name="date_changed", tzinfo=timezone.utc, allow_none=False
    )

    what_changed = DBEnum(
        name="what_changed", allow_none=False, enum=VulnerabilityChange
    )

    old_value = Unicode(name="old_value", allow_none=True)

    new_value = Unicode(name="new_value", allow_none=True)

    def __init__(
        self,
        vulnerability,
        changer,
        what_changed=None,
        old_value=None,
        new_value=None,
    ):
        super().__init__()
        self.vulnerability = vulnerability
        self.changer = changer
        self.what_changed = what_changed
        self.old_value = old_value
        self.new_value = new_value
        self.date_changed = UTC_NOW


@implementer(IVulnerabilityActivitySet)
class VulnerabilityActivitySet:
    def new(
        self,
        vulnerability,
        changer,
        what_changed,
        old_value=None,
        new_value=None,
    ):
        """See `IVulnerabilityActivitySet`."""
        store = IStore(VulnerabilityActivity)
        activity = VulnerabilityActivity(
            vulnerability, changer, what_changed, old_value, new_value
        )
        store.add(activity)
        return activity


def get_vulnerability_privacy_filter(user):
    """Returns the filter for all vulnerabilities that the given user has
    access to, including private vulnerabilities where the user has proper
    permission.

    :param user: An IPerson, or a class attribute that references an IPerson
                 in the database.
    :return: A Storm condition.
    """
    from lp.registry.model.accesspolicy import AccessPolicyGrant

    public_vulnerabilities_filter = Vulnerability._information_type.is_in(
        PUBLIC_INFORMATION_TYPES
    )

    if user is None:
        return [public_vulnerabilities_filter]
    elif IPersonRoles.providedBy(user):
        user = user.person

    artifact_grant_query = Coalesce(
        ArrayIntersects(
            SQL("Vulnerability.access_grants"),
            Select(
                ArrayAgg(TeamParticipation.team_id),
                tables=TeamParticipation,
                where=(TeamParticipation.person == user),
            ),
        ),
        False,
    )

    policy_grant_query = Coalesce(
        ArrayIntersects(
            Array(SQL("Vulnerability.access_policy")),
            Select(
                ArrayAgg(AccessPolicyGrant.policy_id),
                tables=(
                    AccessPolicyGrant,
                    Join(
                        TeamParticipation,
                        TeamParticipation.team_id
                        == AccessPolicyGrant.grantee_id,
                    ),
                ),
                where=(TeamParticipation.person == user),
            ),
        ),
        False,
    )
    return [
        Or(
            public_vulnerabilities_filter,
            artifact_grant_query,
            policy_grant_query,
        )
    ]
