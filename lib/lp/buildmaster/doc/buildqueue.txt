BuildQueue
==========

BuildQueue class represents the run-time-records of builds being
processed.

See buildd-queuebuilder.txt for more information about the BuildQueue
initialization.

BuildQueue should provide all the information needed for dispatching
and collecting build results.

As soon as a build job is processed succesfully (dispatched &
collected) the BuildQueue record representing it is removed.

    >>> from lp.testing import verifyObject
    >>> from lp.services.propertycache import get_property_cache
    >>> from lp.buildmaster.interfaces.buildqueue import (
    ...     IBuildQueue, IBuildQueueSet)

Get an instance of Builder from the current sampledata using the
IBuildQueueSet zope utility. The zope utility itself will be
documented later on this document, we are only using it to retrive an
IBuildQueue record with the security proxies in place:

    >>> bq = getUtility(IBuildQueueSet).get(1)

Instances returned by IBuildQueueSet provides the IBuildQueue interface:

    >>> verifyObject(IBuildQueue, bq)
    True

The IBuild record related to this job is provided by the 'build'
attribute:

    >>> from lp.soyuz.interfaces.binarypackagebuild import (
    ...     IBinaryPackageBuildSet,
    ...     )
    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(bq)
    >>> build.id
    8
    >>> build.status.name
    'BUILDING'

The timestamp of when the job was dispatched is provided as datetime
instances:

    >>> bq.date_started
    datetime.datetime(2005, 6, 15, 9, 20, 12, 820778, tzinfo=<UTC>)

Check Builder foreign key, which indicated which builder 'is processing'
the job in question:

The 'builder' attribute provides the IBuilder instance of the builder
currently processing this job:

    >>> print(bq.builder.name)
    bob

'logtail' is a text field which stores up to 1 Kbyte of the last
logged actions during the build process, it is updated according to the
frequency set in buildd-slavescanner, normally 10 seconds, see
buildd-slavescanner.txt for further information:

    >>> print(bq.logtail)
    Dummy sampledata entry, not processing

'lastscore' is the heuristic index generated by queuebuilder to order
the dispatching process, see more information in
buildd-queuebuilder.txt:

    >>> bq.lastscore
    1

'manual' is a boolean, which is meant to suppress the auto-scoring
procedure, i.e., when it is set the job do not get re-scored, it is
used to manually reorder jobs via the web UI:

    >>> bq.manual
    False

BuildQueue provides a method to handle "manual scoring" procedure
properly, in order to retain the manually set score we need to
set 'manual' attribute atomically. For this we use manualScore:

    >>> pending_bq = getUtility(IBuildQueueSet).get(2)

    >>> pending_bq.manual, pending_bq.lastscore
    (False, 10)
    >>> pending_bq.manualScore(1000)

    >>> pending_bq.manual, pending_bq.lastscore
    (True, 1000)


Dispatching and Reseting jobs
-----------------------------

The sampledata contains an active job, being built by the 'bob'
builder.

    >>> from lp.buildmaster.interfaces.builder import IBuilderSet

    >>> bob = getUtility(IBuilderSet)['bob']
    >>> job = bob.currentjob

    >>> print(job.builder.name)
    bob
    >>> job.date_started is not None
    True
    >>> print(job.logtail)
    Dummy sampledata entry, not processing
    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(job)
    >>> print(build.status.name)
    BUILDING
    >>> print(job.lastscore)
    1

IBuildQueue.reset() will reset the job, enabling it to be dispatched
to another build. The score value of the job is preserved.

    >>> job.reset()

    >>> del get_property_cache(bob).currentjob
    >>> print(bob.currentjob)
    None

    >>> print(job.status.name)
    WAITING
    >>> print(job.builder)
    None
    >>> print(job.date_started)
    None
    >>> print(job.logtail)
    None
    >>> print(build.status.name)
    NEEDSBUILD
    >>> print(job.lastscore)
    1

On the flip-side, IBuildQueue.markAsBuilding() will assign the job to
the specified builder.

    >>> job.markAsBuilding(bob)

    >>> del get_property_cache(bob).currentjob
    >>> bob.currentjob == job
    True

    >>> print(job.builder.name)
    bob
    >>> job.date_started is not None
    True
    >>> print(build.status.name)
    BUILDING


BuildQueueSet utility
---------------------

Now perform the tests for the BuildQueue zope utility, BuildQueueSet.
Check if the instance returned as utility corresponds to its
respective interface:

    >>> bqset = getUtility(IBuildQueueSet)
    >>> verifyObject(IBuildQueueSet, bqset)
    True

IBuildQueueSet utility provides a 'get' method:

    >>> bqset.get(2).id
    2

Another method to fetch the BuildQueue being processed for a builder,
there should be only one since the builders are sigle-task
applications:

    >>> current_job = bqset.getByBuilder(bob)
    >>> print(current_job.builder.name)
    bob
