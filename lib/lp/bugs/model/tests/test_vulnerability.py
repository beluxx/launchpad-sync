# Copyright 2022 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

"""Tests for the vulnerability and related models."""
from fixtures import MockPatch
from storm.store import Store
from testtools.matchers import MatchesStructure
from zope.component import getUtility
from zope.security.proxy import removeSecurityProxy

from lp.app.enums import InformationType
from lp.app.errors import (
    SubscriptionPrivacyViolation,
    UserCannotUnsubscribePerson,
)
from lp.app.interfaces.launchpad import ILaunchpadCelebrities
from lp.app.interfaces.services import IService
from lp.bugs.enums import VulnerabilityStatus
from lp.bugs.interfaces.buglink import IBugLinkTarget
from lp.bugs.interfaces.bugtask import BugTaskImportance
from lp.bugs.interfaces.vulnerability import (
    IVulnerability,
    IVulnerabilitySet,
    VulnerabilityChange,
)
from lp.bugs.model.vulnerabilitysubscription import VulnerabilitySubscription
from lp.registry.enums import BugSharingPolicy, TeamMembershipPolicy
from lp.services.webapp.authorization import check_permission
from lp.testing import (
    TestCaseWithFactory,
    admin_logged_in,
    anonymous_logged_in,
    person_logged_in,
    verifyObject,
)
from lp.testing.layers import DatabaseFunctionalLayer


def grant_access_to_non_public_vulnerability(vulnerability, person):
    distribution = removeSecurityProxy(vulnerability).distribution
    with person_logged_in(distribution.owner):
        getUtility(IService, "sharing").ensureAccessGrants(
            [person],
            distribution.owner,
            vulnerabilities=[vulnerability],
        )


class TestVulnerability(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def setUp(self):
        super().setUp()
        self.distribution = self.factory.makeDistribution()
        self.vulnerability = self.factory.makeVulnerability(
            distribution=self.distribution
        )

    def makeProprietaryDistribution(self):
        return self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY
        )

    def makeProprietaryVulnerability(self, distribution=None):
        if distribution is None:
            distribution = self.makeProprietaryDistribution()
        return self.factory.makeVulnerability(
            distribution=distribution,
            information_type=InformationType.PROPRIETARY,
        )

    def test_Vulnerability_implements_IVulnerability(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(verifyObject(IVulnerability, vulnerability))

    def test_Vulnerability_implements_IBugLinkTarget(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(verifyObject(IBugLinkTarget, vulnerability))

    def test_Vulnerability_subscriptions_subscribers_empty_default(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(0, vulnerability.subscribers.count())
        self.assertEqual(0, vulnerability.subscriptions.count())

    def test_public_vulnerability_visibleByUser(self):
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.visibleByUser(None))
        self.assertTrue(vulnerability.visibleByUser(self.factory.makePerson()))

    def test_non_public_vulnerability_visibleByUser(self):
        # XXX lgp171188 - We use the 'Proprietary' sharing policy
        # as an example non-public information_type and may have to
        # add tests for other non-public types in the future.
        distribution = self.makeProprietaryDistribution()
        vulnerability = self.makeProprietaryVulnerability(distribution)
        allowed_user = self.factory.makePerson()
        grant_access_to_non_public_vulnerability(
            vulnerability,
            allowed_user,
        )
        with person_logged_in(distribution.owner):
            self.assertFalse(vulnerability.visibleByUser(None))
            self.assertFalse(
                vulnerability.visibleByUser(self.factory.makePerson())
            )
            self.assertTrue(vulnerability.visibleByUser(allowed_user))

    def test_setting_information_type_reconciles_access(self):
        mock_reconcile_method = self.useFixture(
            MockPatch(
                "lp.bugs.model.vulnerability.reconcile_access_for_artifacts"
            )
        ).mock
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(
            InformationType.PUBLIC, vulnerability.information_type
        )
        with person_logged_in(vulnerability.distribution.owner):
            vulnerability.information_type = InformationType.PROPRIETARY
        mock_reconcile_method.assert_called_with(
            [vulnerability],
            InformationType.PROPRIETARY,
            [vulnerability.distribution],
        )

    def test_getSubscription_person_is_None(self):
        self.assertIsNone(
            self.factory.makeVulnerability().getSubscription(None)
        )

    def test_getSubscription_person_is_not_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertIsNone(vulnerability.getSubscription(person))

    def test_getSubscription_person_is_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        subscription = VulnerabilitySubscription(
            person=person, vulnerability=vulnerability, subscribed_by=person
        )
        self.assertEqual(subscription, vulnerability.getSubscription(person))

    def test_hasSubscription(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(person))
        VulnerabilitySubscription(
            person=person,
            vulnerability=vulnerability,
            subscribed_by=person,
        )
        self.assertTrue(vulnerability.hasSubscription(person))

    def test_userCanBeSubscribed_person_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.userCanBeSubscribed(person))

    def test_userCanBeSubscribed_person_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertTrue(vulnerability.userCanBeSubscribed(person))

    def test_userCanBeSubscribed_public_vulnerability_non_open_team(self):
        team = self.factory.makeTeam(
            membership_policy=TeamMembershipPolicy.RESTRICTED
        )
        self.assertFalse(team.anyone_can_join())
        vulnerability = self.factory.makeVulnerability()
        self.assertTrue(vulnerability.userCanBeSubscribed(team))

    def test_userCanBeSubscribed_non_public_vulnerability_non_open_team(self):
        team = self.factory.makeTeam(
            membership_policy=TeamMembershipPolicy.RESTRICTED,
        )
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertTrue(vulnerability.userCanBeSubscribed(team))

    def test_userCanBeSubscribed_non_public_vulnerability_open_team(self):
        team = removeSecurityProxy(self.factory.makeTeam())
        self.assertTrue(team.anyone_can_join())
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability(
                self.makeProprietaryDistribution()
            )
        )
        self.assertFalse(vulnerability.userCanBeSubscribed(team))

    def test_subscribe_person_to_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, vulnerability.distribution.owner)
        self.assertTrue(vulnerability.hasSubscription(person))

        non_public_vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = non_public_vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            non_public_vulnerability.subscribe(
                person,
                distribution_owner,
            )
            self.assertTrue(non_public_vulnerability.hasSubscription(person))

    def test_subscribe_open_team_non_public_vulnerability(self):
        open_team = self.factory.makeTeam()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            self.assertRaises(
                SubscriptionPrivacyViolation,
                vulnerability.subscribe,
                open_team,
                distribution_owner,
            )

    def test_subscribe_open_team_public_vulnerability(self):
        open_team = self.factory.makeTeam()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(open_team))
        vulnerability.subscribe(open_team, vulnerability.distribution.owner)
        self.assertTrue(vulnerability.hasSubscription(open_team))

    def test_subscribe_subscribing_a_person_with_existing_subscription(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(
            person,
            vulnerability.distribution.owner,
        )
        self.assertTrue(vulnerability.hasSubscription(person))
        self.assertEqual(
            1,
            Store.of(vulnerability)
            .find(
                VulnerabilitySubscription,
                VulnerabilitySubscription.person == person,
                VulnerabilitySubscription.vulnerability == vulnerability,
            )
            .count(),
        )
        vulnerability.subscribe(
            person,
            vulnerability.distribution.owner,
        )
        self.assertTrue(vulnerability.hasSubscription(person))
        self.assertEqual(
            1,
            Store.of(vulnerability)
            .find(
                VulnerabilitySubscription,
                VulnerabilitySubscription.person == person,
                VulnerabilitySubscription.vulnerability == vulnerability,
            )
            .count(),
        )

        vulnerability2 = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability2.distribution.owner
        with person_logged_in(distribution_owner):
            vulnerability2.subscribe(person, distribution_owner)
            self.assertTrue(vulnerability2.hasSubscription(person))
            vulnerability2.subscribe(person, distribution_owner)
            self.assertTrue(vulnerability2.hasSubscription(person))

    def test_subscribing_to_non_public_vulnerability_makes_it_visible(self):
        person = self.factory.makePerson()
        vulnerability = self.makeProprietaryVulnerability()
        distribution_owner = removeSecurityProxy(
            vulnerability
        ).distribution.owner
        with person_logged_in(person):
            self.assertFalse(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

        with person_logged_in(distribution_owner):
            vulnerability.subscribe(person, distribution_owner)
        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

    def test_subscribers_subscriptions(self):
        person1 = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertEqual(0, vulnerability.subscriptions.count())
        self.assertEqual(0, vulnerability.subscribers.count())
        vulnerability.subscribe(person1, person1)
        vulnerability.subscribe(person2, person2)
        self.assertContentEqual({person1, person2}, vulnerability.subscribers)
        self.assertEqual(2, vulnerability.subscriptions.count())

    def test_unsubscribe_user_not_subscribed(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        self.assertFalse(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, person)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_unsubscribe_random_user_cannot_unsubscribe_a_subscriber(self):
        person = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertRaises(
            UserCannotUnsubscribePerson,
            vulnerability.unsubscribe,
            person,
            person2,
        )

    def test_unsubscribe_self(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, person)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_vulnerability_creator_can_unsubscribe_subscribers(self):
        creator_member = self.factory.makePerson()
        person = self.factory.makePerson()
        creator = self.factory.makeTeam(members=[creator_member])
        vulnerability = self.factory.makeVulnerability(creator=creator)
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, creator_member)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_distribution_owner_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, vulnerability.distribution.owner)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_distribution_security_admins_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        security_member = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        with person_logged_in(vulnerability.distribution.owner):
            vulnerability.distribution.security_admin = self.factory.makeTeam(
                members=[security_member]
            )
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(person, security_member)
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_creator_of_a_subscription_can_unsubscribe_the_subscriber(self):
        person = self.factory.makePerson()
        person2 = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person2, person)
        self.assertTrue(vulnerability.hasSubscription(person2))
        vulnerability.unsubscribe(person2, person)
        self.assertFalse(vulnerability.hasSubscription(person2))

    def test_admins_can_unsubscribe_subscribers(self):
        person = self.factory.makePerson()
        vulnerability = self.factory.makeVulnerability()
        vulnerability.subscribe(person, person)
        self.assertTrue(vulnerability.hasSubscription(person))
        vulnerability.unsubscribe(
            person, getUtility(ILaunchpadCelebrities).admin.teamowner
        )
        self.assertFalse(vulnerability.hasSubscription(person))

    def test_unsubscribe_removes_visibility_of_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = removeSecurityProxy(
            self.makeProprietaryVulnerability()
        )
        distribution_owner = vulnerability.distribution.owner
        with person_logged_in(distribution_owner):
            vulnerability.subscribe(person, distribution_owner)

        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))
            vulnerability.unsubscribe(person, person)

        # Have to re-login again for the permission cache to get invalidated.
        with person_logged_in(person):
            self.assertFalse(check_permission("launchpad.View", vulnerability))

    def test_random_user_permissions(self):
        with person_logged_in(self.factory.makePerson()):
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertFalse(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_random_user_permissions_non_public_vulnerability(self):
        vulnerability = self.makeProprietaryVulnerability()
        with person_logged_in(self.factory.makePerson()):
            self.assertFalse(check_permission("launchpad.View", vulnerability))

    def test_user_can_view_shared_non_public_vulnerability(self):
        person = self.factory.makePerson()
        vulnerability = self.makeProprietaryVulnerability()
        grant_access_to_non_public_vulnerability(vulnerability, person)
        with person_logged_in(person):
            self.assertTrue(check_permission("launchpad.View", vulnerability))

    def test_admin_permissions(self):
        with admin_logged_in():
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_distribution_owner_permissions(self):
        with person_logged_in(self.distribution.owner):
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_security_admin_permissions(self):
        person = self.factory.makePerson()
        security_team = self.factory.makeTeam(members=[person])
        with person_logged_in(self.distribution.owner):
            self.distribution.security_admin = security_team

        with person_logged_in(person):
            self.assertTrue(
                check_permission("launchpad.Edit", self.vulnerability)
            )

    def test_anonymous_permissions(self):
        with anonymous_logged_in():
            self.assertTrue(
                check_permission("launchpad.View", self.vulnerability)
            )
            self.assertFalse(
                check_permission("launchpad.Edit", self.vulnerability)
            )
        distribution = self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY
        )
        vulnerability = self.factory.makeVulnerability(
            distribution=distribution,
            information_type=InformationType.PROPRIETARY,
        )
        with anonymous_logged_in():
            self.assertFalse(check_permission("launchpad.View", vulnerability))
            self.assertFalse(check_permission("launchpad.Edit", vulnerability))

    def test_edit_vulnerability_security_admin(self):
        person = self.factory.makePerson()
        security_team = self.factory.makeTeam(members=[person])
        vulnerability = self.factory.makeVulnerability(
            distribution=self.distribution
        )
        cve = self.factory.makeCVE("2022-1234")
        with person_logged_in(self.distribution.owner):
            self.distribution.security_admin = security_team

        with person_logged_in(security_team):
            vulnerability.cve = cve
            vulnerability.status = VulnerabilityStatus.ACTIVE
            self.assertThat(
                vulnerability,
                MatchesStructure.byEquality(
                    cve=cve, status=VulnerabilityStatus.ACTIVE
                ),
            )


class TestVulnerabilityActivity(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def test_vulnerability_activity_changes(self):
        vulnerability = self.factory.makeVulnerability()
        changer = self.factory.makePerson()
        activity = self.factory.makeVulnerabilityActivity(
            vulnerability=vulnerability, changer=None
        )
        with person_logged_in(changer):
            self.assertTrue(
                VulnerabilityChange.DESCRIPTION, activity.what_changed
            )


class TestVulnerabilitySet(TestCaseWithFactory):
    layer = DatabaseFunctionalLayer

    def test_VulnerabilitySet_implements_IVulnerabilitySet(self):
        vulnerabilitySet = getUtility(IVulnerabilitySet)
        self.assertTrue(verifyObject(IVulnerabilitySet, vulnerabilitySet))

    def test_bugVulnerabilityCount(self):
        # vulnerability3 linked bugs will not be reflected
        # in computations of linked bugs on
        # vulnerability 1 and 2

        vulnerability1 = self.factory.makeVulnerability()
        vulnerability2 = self.factory.makeVulnerability()
        vulnerability3 = self.factory.makeVulnerability()
        bug1 = self.factory.makeBug()
        bug2 = self.factory.makeBug()
        initial_number = len(vulnerability1.bugs)
        with admin_logged_in():
            vulnerability1.linkBug(bug1)
            vulnerability3.linkBug(bug1)
            vulnerability3.linkBug(bug2)

        self.assertEqual(initial_number + 1, len(vulnerability1.bugs))

        with admin_logged_in():
            vulnerability2.linkBug(bug2)
        self.assertEqual(
            initial_number + 2,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

        with admin_logged_in():
            vulnerability2.linkBug(bug1)
        self.assertEqual(
            initial_number + 3,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

        with admin_logged_in():
            vulnerability1.unlinkBug(bug1)
            vulnerability2.unlinkBug(bug2)
            vulnerability2.unlinkBug(bug1)
        self.assertEqual(
            initial_number,
            (len(vulnerability1.bugs) + len(vulnerability2.bugs)),
        )

    def test_access_reconciled_after_creating_a_vulnerability(self):
        mock_reconcile_method = self.useFixture(
            MockPatch(
                "lp.bugs.model.vulnerability.reconcile_access_for_artifacts"
            )
        ).mock
        distribution = self.factory.makeDistribution()
        creator = self.factory.makePerson()
        vulnerability = getUtility(IVulnerabilitySet).new(
            distribution=distribution,
            status=VulnerabilityStatus.NEEDS_TRIAGE,
            importance=BugTaskImportance.UNDECIDED,
            creator=creator,
        )
        mock_reconcile_method.assert_called_with(
            [vulnerability], vulnerability.information_type, [distribution]
        )

    def test_findByIds(self):
        person = self.factory.makePerson()
        proprietary_distribution = self.factory.makeDistribution(
            bug_sharing_policy=BugSharingPolicy.PROPRIETARY,
        )
        vulnerability1 = removeSecurityProxy(self.factory.makeVulnerability())
        vulnerability2 = removeSecurityProxy(
            self.factory.makeVulnerability(
                distribution=proprietary_distribution,
                information_type=InformationType.PROPRIETARY,
            )
        )
        vulnerability3 = removeSecurityProxy(
            self.factory.makeVulnerability(
                distribution=proprietary_distribution,
                information_type=InformationType.PROPRIETARY,
            )
        )
        grant_access_to_non_public_vulnerability(vulnerability2, person)
        vulnerability_set = getUtility(IVulnerabilitySet)
        self.assertContentEqual(
            {vulnerability1, vulnerability2, vulnerability3},
            vulnerability_set.findByIds(
                [
                    vulnerability1.id,
                    vulnerability2.id,
                    vulnerability3.id,
                ]
            ),
        )
        self.assertContentEqual(
            {vulnerability1, vulnerability2},
            vulnerability_set.findByIds(
                [
                    vulnerability1.id,
                    vulnerability2.id,
                    vulnerability3.id,
                ],
                visible_by_user=person,
            ),
        )
